# Implement ListenerToken Remove API with Unified Native Storage

## Overview

Add a `ListenerToken` class in TypeScript that wraps the UUID token string and provides a `remove()` method, matching the native Android and iOS APIs. Simplify the native bridge by consolidating all listener storage into a single unified dictionary with type metadata, enabling a generic `listenerToken_Remove` bridge method that all listeners use.

## Key Architecture Decisions

### 1. TypeScript Side: Direct Generic Bridge Call

- `ListenerToken.remove()` calls `listenerToken_Remove` bridge method directly
- `collection.removeChangeListener(token)` delegates to `token.remove()`
- Both APIs work, maintaining backward compatibility
- **Future-proof**: Token is independent of specific remove methods

### 2. Native Side: Unified Storage with Type Metadata

- Replace 5 separate dictionaries with 1 unified dictionary
- Store listener type metadata when adding listeners
- Retrieve type metadata when removing listeners (no need to pass type)
- Enable generic `listenerToken_Remove` bridge method
- Keep old bridge methods for backward compatibility (they delegate to generic method)

### 3. Clear Naming Convention

- `uuidToken`: UUID string generated by React Native (e.g., "listener-abc-123")
- `cblListenerToken`: TypeScript ListenerToken class instance
- `nativeToken`: Native iOS/Android ListenerToken object
- `allListenerTokensByUuid`: Unified storage map in native bridge

### 4. Flow Independence

```
token.remove() → listenerToken_Remove (generic) → native removal
```

NOT:

```
token.remove() → collection_RemoveChangeListener (specific) → native removal
```

---

## Step-by-Step Implementation

### Step 1: Create TypeScript ListenerToken Class

**File**: Create new file `src/cblite-js/cblite/src/listener-token.ts`

**Purpose**: Wraps a UUID token string and provides a `remove()` method that calls the generic bridge method

**Code**:

````typescript
/**
 * ListenerToken - A wrapper around a UUID token string that provides
 * a convenient remove() method.
 * 
 * This class represents a listener token returned when adding a change listener.
 * It matches the native iOS and Android ListenerToken APIs.
 * 
 * IMPORTANT: The remove() method calls the generic listenerToken_Remove bridge
 * method, making it independent of specific remove methods (collection_RemoveChangeListener,
 * query_RemoveChangeListener, etc.) which may be deprecated in the future.
 * 
 * Naming Convention:
 * - uuidToken: The UUID string identifier (e.g., "listener-abc-123")
 * - cblListenerToken: An instance of this ListenerToken class
 * - nativeToken: The native iOS/Android ListenerToken object
 * 
 * @example
 * ```typescript
 * // Add a listener - get a CBL ListenerToken object
 * const cblListenerToken = await collection.addChangeListener((change) => {
 *   console.log('Changed!', change.documentIDs);
 * });
 * 
 * // Remove the listener
 * await cblListenerToken.remove();
 * ```
 */
export class ListenerToken {
  /**
   * The UUID string that identifies this listener in the bridge.
   * Generated by React Native (TypeScript side).
   * Example: "listener-abc-123-def-456"
   */
  private readonly _uuidToken: string;
  
  /**
   * Callback function that removes the listener.
   * This function calls the GENERIC listenerToken_Remove bridge method.
   */
  private readonly _removeCallbackFunction: () => Promise<void>;
  
  /**
   * Flag indicating whether remove() has been called.
   * Prevents double-removal.
   */
  private _isRemovedFlag: boolean = false;

  /**
   * Creates a new ListenerToken.
   * 
   * @param uuidToken - The UUID string identifier (e.g., "listener-abc-123")
   * @param removeCallbackFunction - Function to call when remove() is invoked
   * 
   * @internal - Users should not call this directly. It's called by
   *             Collection, Query, and Replicator classes.
   */
  constructor(uuidToken: string, removeCallbackFunction: () => Promise<void>) {
    this._uuidToken = uuidToken;
    this._removeCallbackFunction = removeCallbackFunction;
  }

  /**
   * Removes the listener associated with this token.
   * 
   * This is the primary method for removing listeners. It:
   * 1. Checks if already removed (no-op if true)
   * 2. Calls the remove callback function
   * 3. The callback calls the GENERIC listenerToken_Remove bridge method
   * 4. The bridge looks up the listener by UUID in unified storage
   * 5. The bridge retrieves the native token and its type from metadata
   * 6. The bridge calls nativeToken.remove()
   * 7. Marks this token as removed
   * 
   * Safe to call multiple times - subsequent calls after the first are no-ops.
   * 
   * @returns Promise that resolves when the listener is removed
   * 
   * @example
   * ```typescript
   * const cblListenerToken = await collection.addChangeListener(...);
   * 
   * // Later, remove the listener
   * await cblListenerToken.remove();
   * 
   * // Calling again is safe (does nothing)
   * await cblListenerToken.remove(); // No error, just returns immediately
   * ```
   */
  async remove(): Promise<void> {
    if (this._isRemovedFlag) {
      // Already removed, don't do it again
      return;
    }
    
    // Call the callback (which calls the GENERIC bridge method)
    await this._removeCallbackFunction();
    
    // Mark as removed
    this._isRemovedFlag = true;
  }

  /**
   * Gets the underlying UUID token string.
   * 
   * This is provided for:
   * - Internal use by Collection/Query/Replicator classes
   * - Backward compatibility
   * - Debugging (to see what the UUID is)
   * 
   * Most users won't need this - just call remove() instead!
   * 
   * @returns The UUID token string (e.g., "listener-abc-123")
   * 
   * @example
   * ```typescript
   * const cblListenerToken = await collection.addChangeListener(...);
   * console.log('UUID:', cblListenerToken.getUuidToken()); // "listener-abc-123"
   * ```
   */
  getUuidToken(): string {
    return this._uuidToken;
  }

  /**
   * Checks if this listener has been removed.
   * 
   * @returns true if remove() has been called, false otherwise
   * 
   * @example
   * ```typescript
   * const cblListenerToken = await collection.addChangeListener(...);
   * console.log(cblListenerToken.isRemoved()); // false
   * 
   * await cblListenerToken.remove();
   * console.log(cblListenerToken.isRemoved()); // true
   * ```
   */
  isRemoved(): boolean {
    return this._isRemovedFlag;
  }
}
````

---

### Step 2: Add Generic Bridge Method to Core Types

**File**: `src/cblite-js/cblite/core-types.ts`

**Add to ICoreEngine interface** (around line 100):

```typescript
/**
 * Generic method to remove any listener by its UUID token.
 * This method works with all listener types (collection, query, replicator, etc.).
 * 
 * @param args Object containing the changeListenerToken (UUID string)
 * @returns Promise that resolves when the listener is removed
 */
listenerToken_Remove(args: {
  changeListenerToken: string;
}): Promise<void>;
```

---

### Step 3: Implement Generic Bridge Method in React Native Engine

**File**: `src/CblReactNativeEngine.tsx`

**Add implementation** (around line 1143, after other listener methods):

```typescript
/**
 * Generic method to remove any listener by its UUID token.
 * Calls the native listenerToken_Remove bridge method.
 */
listenerToken_Remove(args: { changeListenerToken: string }): Promise<void> {
  return new Promise((resolve, reject) => {
    this.CblReactNative.listenerToken_Remove(
      args.changeListenerToken,
      () => {
        this.debugLog(
          `::DEBUG:: Successfully removed listener with token ${args.changeListenerToken}`
        );
        resolve();
      },
      (error: any) => {
        this.debugLog(
          `::ERROR:: Failed to remove listener with token ${args.changeListenerToken}: ${error}`
        );
        reject(error);
      }
    );
  });
}
```

---

### Step 4: Create Native Unified Storage Structures

#### iOS (Swift)

**File**: `ios/CblReactnative.swift`

**Add these structures at the top of the file** (around line 10, after imports):

```swift
/**
 * Metadata for storing listener information in unified dictionary.
 * 
 * This struct wraps the native ListenerToken along with its type.
 * When adding a listener, we store both the token and its type.
 * When removing a listener, we look up by UUID and get both back.
 * 
 * This eliminates the need to pass the type when removing - it's
 * already stored in the metadata!
 */
struct ListenerMetadata {
  let nativeToken: ListenerToken
  let listenerType: ListenerType
}

/**
 * Enum representing the type of listener.
 * 
 * This allows us to identify what kind of listener a token represents,
 * useful for debugging and filtering.
 */
enum ListenerType: String {
  case collection
  case collectionDocument
  case query
  case replicator
  case replicatorDocument
}
```

**Replace the existing listener dictionaries** (lines 13-20):

**Before**:

```swift
var databaseChangeListeners = [String: Any]()

var collectionChangeListeners = [String: Any]()
var collectionDocumentChangeListeners = [String: Any]()
var queryChangeListeners = [String: Any]()

var replicatorChangeListeners = [String: Any]()
var replicatorDocumentChangeListeners = [String: Any]()
```

**After**:

```swift
/**
 * Unified storage for all listener tokens.
 * 
 * Key: UUID token string (e.g., "listener-abc-123")
 * Value: ListenerMetadata containing the native token and its type
 * 
 * When adding a listener:
 *   allListenerTokensByUuid[uuid] = ListenerMetadata(nativeToken, type)
 * 
 * When removing a listener:
 *   metadata = allListenerTokensByUuid[uuid]
 *   metadata.nativeToken.remove()  // Native token
 *   metadata.listenerType           // Type (for debugging)
 * 
 * This replaces the previous separate dictionaries:
 * - collectionChangeListeners
 * - collectionDocumentChangeListeners
 * - queryChangeListeners
 * - replicatorChangeListeners
 * - replicatorDocumentChangeListeners
 */
var allListenerTokensByUuid: [String: ListenerMetadata] = [:]
```

#### Android (Kotlin)

**File**: `android/src/main/java/com/cblreactnative/CblReactnativeModule.kt`

**Add these structures at the top of the class** (around line 28):

```kotlin
/**
 * Metadata for storing listener information in unified map.
 * 
 * When adding a listener, we store both the token and its type.
 * When removing a listener, we look up by UUID and get both back.
 */
data class ListenerMetadata(
  val nativeToken: ListenerToken,
  val listenerType: ListenerType
)

/**
 * Enum representing the type of listener.
 */
enum class ListenerType {
  COLLECTION,
  COLLECTION_DOCUMENT,
  QUERY,
  REPLICATOR,
  REPLICATOR_DOCUMENT
}
```

**Replace the existing listener maps** (lines 32-36):

**Before**:

```kotlin
private val queryChangeListeners: MutableMap<String, ListenerToken> = mutableMapOf()
private val replicatorChangeListeners: MutableMap<String, ListenerToken> = mutableMapOf()
private val replicatorDocumentListeners: MutableMap<String, ListenerToken> = mutableMapOf()
private val collectionChangeListeners: MutableMap<String, ListenerToken> = mutableMapOf()
private val collectionDocumentChangeListeners: MutableMap<String, ListenerToken> = mutableMapOf()
```

**After**:

```kotlin
/**
 * Unified storage for all listener tokens.
 * 
 * Key: UUID token string (e.g., "listener-abc-123")
 * Value: ListenerMetadata containing the native token and its type
 */
private val allListenerTokensByUuid: MutableMap<String, ListenerMetadata> = mutableMapOf()
```

---

### Step 5: Add Generic Remove Method to Native Bridge

#### iOS (Swift)

**File**: `ios/CblReactnative.swift`

**Add new generic remove method** (add after existing remove methods, around line 1238):

```swift
/**
 * Generic method to remove any type of listener by its UUID token.
 * 
 * This method:
 * 1. Looks up the listener in allListenerTokensByUuid by UUID
 * 2. Retrieves BOTH the native token AND its type from metadata
 * 3. Calls nativeToken.remove() to remove the native listener
 * 4. Removes the entry from the unified dictionary
 * 
 * The type is NOT passed as a parameter - it's retrieved from the stored metadata!
 * This is why unified storage is powerful: UUID → (Token + Type)
 * 
 * @param changeListenerToken The UUID token string
 */
@objc(listenerToken_Remove:withResolver:withRejecter:)
func listenerToken_Remove(
  changeListenerToken: NSString,
  resolve: @escaping RCTPromiseResolveBlock,
  reject: @escaping RCTPromiseRejectBlock
) -> Void {
  let uuidToken = String(changeListenerToken)
  
  backgroundQueue.async {
    // Look up by UUID - gets BOTH token AND type
    if let metadata = self.allListenerTokensByUuid[uuidToken] {
      // Remove the native listener
      metadata.nativeToken.remove()
      
      // Remove from unified dictionary
      self.allListenerTokensByUuid.removeValue(forKey: uuidToken)
      
      self.logger.debug("::SWIFT DEBUG:: listenerToken_Remove: Removed \(metadata.listenerType.rawValue) listener with token \(uuidToken)")
      resolve(nil)
    } else {
      let errorMsg = "No listener found for token \(uuidToken)"
      self.logger.error("::SWIFT DEBUG:: listenerToken_Remove: \(errorMsg)")
      reject("LISTENER_ERROR", errorMsg, nil)
    }
  }
}
```

**Update Objective-C bridge** (`ios/CblReactnative.mm`):

Add this declaration (around line 277):

```objc
RCT_EXTERN_METHOD(listenerToken_Remove:(NSString *)changeListenerToken
                  withResolver:(RCTPromiseResolveBlock)resolve
                  withRejecter:(RCTPromiseRejectBlock)reject)
```

#### Android (Kotlin)

**File**: `android/src/main/java/com/cblreactnative/CblReactnativeModule.kt`

**Add new generic remove method** (add after existing remove methods, around line 1201):

```kotlin
/**
 * Generic method to remove any type of listener by its UUID token.
 * 
 * This method:
 * 1. Looks up the listener in allListenerTokensByUuid by UUID
 * 2. Retrieves BOTH the native token AND its type from metadata
 * 3. Calls nativeToken.remove() to remove the native listener
 * 4. Removes the entry from the unified map
 * 
 * The type is NOT passed as a parameter - it's retrieved from the stored metadata!
 */
@ReactMethod
fun listenerToken_Remove(
  changeListenerToken: String,
  promise: Promise
) {
  GlobalScope.launch(Dispatchers.IO) {
    try {
      // Look up by UUID - gets BOTH token AND type
      val metadata = allListenerTokensByUuid[changeListenerToken]
      
      if (metadata != null) {
        // Remove the native listener
        metadata.nativeToken.remove()
        
        // Remove from unified map
        allListenerTokensByUuid.remove(changeListenerToken)
        
        context.runOnUiQueueThread {
          promise.resolve(null)
        }
      } else {
        context.runOnUiQueueThread {
          promise.reject("LISTENER_ERROR", "No listener found for token $changeListenerToken")
        }
      }
    } catch (e: Throwable) {
      context.runOnUiQueueThread {
        promise.reject("LISTENER_ERROR", e.message)
      }
    }
  }
}
```

---

### Step 6: Update Native Add Listener Methods to Use Unified Storage

**Pattern for ALL add listener methods**:

#### iOS Example: Collection Add Change Listener

**File**: `ios/CblReactnative.swift` (line 104)

**Before**:

```swift
self.collectionChangeListeners[token] = listener
```

**After**:

```swift
// Store in unified dictionary with type metadata
self.allListenerTokensByUuid[token] = ListenerMetadata(
  nativeToken: listener,
  listenerType: .collection  // Type stored here!
)
```

**Apply same pattern to all add methods**:

- `collection_AddChangeListener` → `.collection`
- `collection_AddDocumentChangeListener` → `.collectionDocument`
- `query_AddChangeListener` → `.query`
- `replicator_AddChangeListener` → `.replicator`
- `replicator_AddDocumentChangeListener` → `.replicatorDocument`

#### Android Example: Collection Add Change Listener

**File**: `android/src/main/java/com/cblreactnative/CblReactnativeModule.kt` (line 655)

**Before**:

```kotlin
collectionChangeListeners[changeListenerToken] = listener
```

**After**:

```kotlin
// Store in unified map with type metadata
allListenerTokensByUuid[changeListenerToken] = ListenerMetadata(
  nativeToken = listener,
  listenerType = ListenerType.COLLECTION  // Type stored here!
)
```

---

### Step 7: Update Native Remove Listener Methods to Delegate

**Pattern for ALL remove listener methods**: Delegate to generic `listenerToken_Remove`

#### iOS Example: Collection Remove Change Listener

**File**: `ios/CblReactnative.swift` (line 169)

**Before** (lines 177-196 - complex logic):

```swift
backgroundQueue.async {
  if let listener = self.collectionChangeListeners[token] as? ListenerToken {
    listener.remove()
    self.collectionChangeListeners.removeValue(forKey: token)
    resolve(nil)
    return
  }
  if let listener = self.collectionDocumentChangeListeners[token] as? ListenerToken {
    listener.remove()
    self.collectionDocumentChangeListeners.removeValue(forKey: token)
    resolve(nil)
    return
  }
  reject("DATABASE_ERROR", "No listener found for token \(token)", nil)
}
```

**After** (simple delegation):

```swift
// Delegate to generic listenerToken_Remove method
listenerToken_Remove(changeListenerToken, resolve: resolve, reject: reject)
```

**Apply to all remove methods**:

- `collection_RemoveChangeListener` → delegate
- `query_RemoveChangeListener` → delegate
- `replicator_RemoveChangeListener` → delegate

#### Android Example: Collection Remove Change Listener

**File**: `android/src/main/java/com/cblreactnative/CblReactnativeModule.kt` (line 667)

**Before** (lines 672-706 - complex logic):

```kotlin
GlobalScope.launch(Dispatchers.IO) {
  try {
    if (collectionChangeListeners.containsKey(changeListenerToken)) {
      val listener = collectionChangeListeners[changeListenerToken]
      listener?.remove()
      collectionChangeListeners.remove(changeListenerToken)
      context.runOnUiQueueThread { promise.resolve(null) }
      return@launch
    }
    if (collectionDocumentChangeListeners.containsKey(changeListenerToken)) {
      val listener = collectionDocumentChangeListeners[changeListenerToken]
      listener?.remove()
      collectionDocumentChangeListeners.remove(changeListenerToken)
      context.runOnUiQueueThread { promise.resolve(null) }
      return@launch
    }
    context.runOnUiQueueThread {
      promise.reject("COLLECTION_ERROR", "No such listener found")
    }
  } catch (e: Throwable) {
    context.runOnUiQueueThread { promise.reject("COLLECTION_ERROR", e.message) }
  }
}
```

**After** (simple delegation):

```kotlin
// Delegate to generic listenerToken_Remove method
listenerToken_Remove(changeListenerToken, promise)
```

---

### Step 8: Update TypeScript Collection Class

**File**: `src/cblite-js/cblite/src/collection.ts`

**Add import** (line 78):

```typescript
import { ListenerToken } from './listener-token';
```

**Add storage maps** (after line 181):

```typescript
/**
 * Map storing CBL ListenerToken objects for collection-wide listeners.
 * Key: UUID token string (e.g., "listener-abc-123")
 * Value: ListenerToken object
 */
private _cblListenerTokensByUuid: Map<string, ListenerToken> = new Map();

/**
 * Map storing CBL ListenerToken objects for document-specific listeners.
 * Key: UUID token string (e.g., "listener-abc-123")
 * Value: ListenerToken object
 */
private _cblDocumentListenerTokensByUuid: Map<string, ListenerToken> = new Map();
```

**Update `addChangeListener()` method** (line 359):

```typescript
async addChangeListener(listener: CollectionChangeListener): Promise<ListenerToken> {
  this._changeListener = listener;
  
  // Generate UUID token (React Native side)
  const uuidToken: string = this.uuid();
  
  if (!this._didStartListener) {
    // Add listener via bridge, passing the UUID token
    await this._engine.collection_AddChangeListener(
      {
        name: this.scope.database.getUniqueName(),
        scopeName: this.scope.name,
        collectionName: this.name,
        changeListenerToken: uuidToken,
      },
      (data, err) => {
        if (err) {
          throw err;
        }
        this.notifyChangeListeners(data);
      }
    );
    this._didStartListener = true;
    
    // Create CBL ListenerToken wrapper
    // IMPORTANT: Callback calls GENERIC listenerToken_Remove, not collection_RemoveChangeListener
    const cblListenerToken = new ListenerToken(uuidToken, async () => {
      // Call the GENERIC bridge method
      await this._engine.listenerToken_Remove({
        changeListenerToken: uuidToken,
      });
      
      // Clean up local storage
      this._cblListenerTokensByUuid.delete(uuidToken);
      this._didStartListener = false;
    });
    
    // Store mapping: UUID → CBL ListenerToken
    this._cblListenerTokensByUuid.set(uuidToken, cblListenerToken);
    
    return cblListenerToken;
  } else {
    throw new Error('Listener already started');
  }
}
```

**Update `addDocumentChangeListener()` method** (line 434) - same pattern

**Update `removeChangeListener()` method** (line 1136):

```typescript
/**
 * Removes a collection-wide change listener.
 * 
 * This method delegates to ListenerToken.remove() for consistency.
 * It accepts either:
 * - A UUID token string (for backward compatibility)
 * - A ListenerToken object
 * 
 * @param token - The token (string or ListenerToken) returned by addChangeListener()
 * @returns Promise that resolves when the listener is removed
 */
async removeChangeListener(token: string | ListenerToken): Promise<void> {
  // Extract UUID token from the parameter
  const uuidToken: string = typeof token === 'string' 
    ? token  // Already a UUID string
    : token.getUuidToken(); // Extract from CBL ListenerToken
  
  // Find the CBL ListenerToken object
  const cblListenerToken = this._cblListenerTokensByUuid.get(uuidToken);
  
  if (cblListenerToken) {
    // Delegate to ListenerToken.remove()
    // This calls listenerToken_Remove (generic bridge method)
    await cblListenerToken.remove();
  } else {
    // Fallback: call generic bridge method directly
    await this._engine.listenerToken_Remove({
      changeListenerToken: uuidToken,
    });
    this._didStartListener = false;
  }
}
```

**Update `removeDocumentChangeListener()` method** (line 1171) - same pattern

---

### Step 9: Update TypeScript Query Class

**File**: `src/cblite-js/cblite/src/query.ts`

**Same pattern as Collection**:

1. Add import for `ListenerToken`
2. Add `_cblQueryListenerTokensByUuid` storage map
3. Update `addChangeListener()` to:

                                                                                                                                                                                                - Return `ListenerToken`
                                                                                                                                                                                                - Callback calls `listenerToken_Remove` (generic)

4. Update `removeChangeListener()` to accept `string | ListenerToken` and delegate

---

### Step 10: Update TypeScript Replicator Class

**File**: `src/cblite-js/cblite/src/replicator.ts`

**Same pattern as Collection**:

1. Add import for `ListenerToken`
2. Add storage maps for both listener types
3. Update both `addChangeListener()` methods to:

                                                                                                                                                                                                - Return `ListenerToken`
                                                                                                                                                                                                - Callback calls `listenerToken_Remove` (generic)

4. Update `removeChangeListener()` to accept `string | ListenerToken` and delegate

---

### Step 11: Update Index Exports

**File**: `src/cblite-js/cblite/src/index.ts`

Add the export:

```typescript
export { ListenerToken } from './listener-token';
```

---

## Architecture Flow Diagram

### Adding a Listener

```
TypeScript: collection.addChangeListener()
    ↓
Generate: uuidToken = "abc-123"
    ↓
Call bridge: collection_AddChangeListener(uuidToken)
    ↓
Native: nativeToken = collection.addChangeListener(...)
    ↓
Native stores: allListenerTokensByUuid["abc-123"] = {
                 nativeToken: <ListenerToken>,
                 listenerType: .collection  ← Type stored!
               }
    ↓
TypeScript creates: cblListenerToken = new ListenerToken(
                      uuidToken,
                      () => engine.listenerToken_Remove({uuidToken})  ← Generic!
                    )
    ↓
Return: cblListenerToken to user
```

### Removing via token.remove()

```
User: token.remove()
    ↓
ListenerToken: calls callback
    ↓
Callback: engine.listenerToken_Remove({uuidToken: "abc-123"})  ← Generic!
    ↓
Bridge: listenerToken_Remove("abc-123")
    ↓
Native looks up: metadata = allListenerTokensByUuid["abc-123"]
    ↓
Native retrieves: {
                    nativeToken: <ListenerToken>,
                    listenerType: .collection  ← Type retrieved!
                  }
    ↓
Native: metadata.nativeToken.remove()
    ↓
Native: allListenerTokensByUuid.removeValue(forKey: "abc-123")
    ↓
✓ Listener removed
```

### Removing via collection.removeChangeListener()

```
User: collection.removeChangeListener(token)
    ↓
Collection: finds cblListenerToken by UUID
    ↓
Collection: delegates to cblListenerToken.remove()
    ↓
[Same flow as above from "ListenerToken: calls callback"]
```

---

## Key Benefits

1. ✅ **Future-Proof**: `token.remove()` calls generic method, independent of specific methods
2. ✅ **Unified Storage**: One dictionary instead of 5 in native code
3. ✅ **Type Metadata**: Type stored when adding, retrieved when removing
4. ✅ **No Type Parameter**: Don't need to pass type to remove method
5. ✅ **Clean API**: Users can call `token.remove()` directly
6. ✅ **Backward Compatible**: Old API still works, delegates to new implementation
7. ✅ **Deprecation Ready**: Specific remove methods can be removed in future
8. ✅ **Simpler Code**: Less duplication in native bridge
9. ✅ **Clear Naming**: Easy to understand what each variable represents

---

## Summary of Changes

| Component | Changes | Files |

|-----------|---------|-------|

| **TypeScript** | Create ListenerToken class | `src/cblite-js/cblite/src/listener-token.ts` (NEW) |

| **TypeScript** | Add generic bridge method to core types | `src/cblite-js/cblite/core-types.ts` |

| **TypeScript** | Implement generic bridge method | `src/CblReactNativeEngine.tsx` |

| **TypeScript** | Update Collection class | `src/cblite-js/cblite/src/collection.ts` |

| **TypeScript** | Update Query class | `src/cblite-js/cblite/src/query.ts` |

| **TypeScript** | Update Replicator class | `src/cblite-js/cblite/src/replicator.ts` |

| **TypeScript** | Export ListenerToken | `src/cblite-js/cblite/src/index.ts` |

| **iOS Native** | Add unified storage structures | `ios/CblReactnative.swift` |

| **iOS Native** | Add generic remove method | `ios/CblReactnative.swift` |

| **iOS Native** | Update all add listener methods | `ios/CblReactnative.swift` |

| **iOS Native** | Update all remove listener methods | `ios/CblReactnative.swift` |

| **iOS Native** | Add bridge declaration | `ios/CblReactnative.mm` |

| **Android Native** | Add unified storage structures | `android/.../CblReactnativeModule.kt` |

| **Android Native** | Add generic remove method | `android/.../CblReactnativeModule.kt` |

| **Android Native** | Update all add listener methods | `android/.../CblReactnativeModule.kt` |

| **Android Native** | Update all remove listener methods | `android/.../CblReactnativeModule.kt` |

| **Tests** | Update to use new API | `expo-example/cblite-js-tests/` |

**Total**: 1 new TypeScript file, 6 modified TypeScript files, 2 modified native files